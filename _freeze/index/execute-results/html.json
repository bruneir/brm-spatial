{
  "hash": "e348f17d33c81882ebd6bc1c8ef9c6db",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Analysing spatial data using R\nsubtitle: Brunei R User Group Meetup ðŸ‡§ðŸ‡³\ndate: '9 March 2023'\nauthor:\n  - name: Haziq Jamil\n    orcid: 0000-0003-3298-1010\n    email: haziq.jamil@ubd.edu.bn\n    url: https://haziqj.ml\n    affiliation: Universiti Brunei Darussalam\n    degrees: PhD\n---\n\n\n\n\n## `https://bruneir.github.io/brm-spatial` {.unlisted}\n\n# Preliminaries\n\nWelcome to the first Brunei R User Group meetup!\n\n::: {layout=\"[ 65, 35 ]\"}\n::: {#first-column}\n<br>\n\n> The RUGS mission is to facilitate the person-to-person exchange of knowledge in small group settings on a global scale. ---R Consortium\n:::\n\n::: {#second-column}\n![](https://bruneir.github.io/bruneiR-Rlogo.jpg)\n\n``` r\nR |> b_unei()\n```\n:::\n:::\n\n<u>About us</u>\n\n-   A group of UBD-ians and R enthusiasts\n-   We want to create a community of R users in Brunei\n-   Champion the Open Source cause\n\nMore events to come this year. Stay tuned!\n\n<!-- This is a hands-on workshop on spatial data analysis using R. We will be using the `bruneimap` package to visualise and analyse spatial data in Brunei Darussalam. -->\n\n::: {.callout-warning title=\"Outcomes\"}\n-   This is a hands-on, live-coding, lecture-style workshop.\n-   Expect to learn...\n    1.  What spatial data is and why it's important.\n    2.  What statistical analysis can be done with spatial data.\n    3.  How to perform spatial analysis using R.\n-   A basic understanding of R is assumed.\n:::\n\n## Getting started with R\n\n-   RStudio overview\n-   Importing data\n-   Installing packages\n\n## Some packages\n\n-   The tidyverse\n-   The [`{bruneimap}`](https://github.com/propertypricebn/bruneimap) package\n\n# Introduction\n\nMotivation...\n\n## Types of GIS data\n\nRoughly speaking, there are 4 types of GIS data.\n\n1.  **Points**\n    -   Having $(X, Y)$ coordinates (latitude, longitude, or projected coordinates, and are \"zero-dimensional\".\n    -   E.g. shopping malls, hospitals, outbreaks, etc.\n2.  **Lines**\n    -   A collection of points that form a path or a boundary. Has length.\n    -   E.g. roads, rivers, pipelines, etc.\n3.  **Polygons**\n    -   A closed area made up of line segments or curves.\n    -   E.g. countries, districts, buildings, etc.\n4.  **Raster**\n    -   Pixelated (or gridded) data where each pixel is associated with a geographical area and some measurement.\n    -   E.g. satellite images, elevation data, etc.\n\nThe first three are usually referred to as *vector data*. GIS data can be stored in various formats such as `.shp` or `.geojson`. The handling of GIS data (at least vector type data) is facilitated by the `{sf}` package [@pebesma2023spatial] which uses the *simple features* standard.\n\n::: callout-note\n*Simple features* refers to a formal standard (ISO 19125-1:2004) that describes how objects in the real world can be represented in computers, with emphasis on the spatial geometry of these objects.\n:::\n\nIt's helpful to think about the shape of this spatial data set. As an example, here's a random slice of 10 kampong-level population data for Brunei:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft_join(\n  kpg_sf, \n  bn_census2021, \n  by = join_by(id, kampong, mukim, district)\n) |>\n  select(\n    kampong, population, geometry\n  ) |>\n  slice_sample(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 10 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 114.0759 ymin: 4.302264 xmax: 115.1357 ymax: 4.994272\nGeodetic CRS:  WGS 84\n# A tibble: 10 Ã— 3\n   kampong                                 population                   geometry\n   <chr>                                        <dbl>              <POLYGON [Â°]>\n 1 Kg. Bukit Puan                                 122 ((114.4237 4.558134, 114.â€¦\n 2 Kg. Tagap                                     2262 ((114.8477 4.91838, 114.8â€¦\n 3 Kg. Sungai Teraban                             974 ((114.1803 4.589528, 114.â€¦\n 4 Kg. Panchor Dulit                              478 ((114.6679 4.810531, 114.â€¦\n 5 Kg. Bukit Sawat                                 98 ((114.5236 4.550425, 114.â€¦\n 6 Hutan Simpan Batu Apoi                          NA ((115.119 4.468916, 115.1â€¦\n 7 Kg. Pangkalan Gadong                          3356 ((114.9201 4.923537, 114.â€¦\n 8 Kg. Sukang                                      57 ((114.6014 4.375045, 114.â€¦\n 9 Perumahan Negara Lambak Kanan Kawasan 2       4771 ((114.9766 4.986692, 114.â€¦\n10 Kg. Sungai Kebun                               465 ((114.947 4.879448, 114.9â€¦\n```\n\n\n:::\n:::\n\n\nSpatial data analysis must have these two components:\n\n1.  The study variables (in the above example, this is population data).\n2.  GIS data regarding that study variable.\n\nIf you only have 1 without 2, then it really is just a regular data analysis (stating the obvious). Adding the GIS data is a process called \"geocoding\" your data points.\n\n::: callout-note\nIn R, geocoding using `{tidyverse}` can be achieved using the `dplyr::left_join()` or similar `xxx_join()` family of functions.\n:::\n\n# Point data\n\nUsing the data from @jaafar2023data . There are three datasets provided.\n\n1.  GIS data ([WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System \"World Geodetic System\") coordinates) of all study plots.\n2.  Soil physicochemical property data. This contains details of soil physical, chemical, nutrient concentration of the three habits studied.\n3.  Soil texture classification. Provides details on the classification of the soil texture in the habitats studied.\n\nWe will first load the data sets in R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load the data sets\nsoil_gps <- read_csv(\n  \"data/8389823/GPS - Revised.csv\", \n  # IMPORTANT!!! The csv file has latin1 encoding as opposed to UTF-8\n  locale = readr::locale(encoding = \"latin1\")\n)\n  \nsoil_physico <- read_csv(\"data/8389823/Soil physicochemical properties.csv\")\nsoil_texture <- read_csv(\"data/8389823/Soil texture classification.csv\")\n```\n:::\n\n\n## Clean up the point data\n\nLet's take a look at the point data set.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nglimpse(soil_gps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 18\nColumns: 5\n$ Forest_type  <chr> \"Kerangas\", \"Kerangas\", \"Kerangas\", \"Kerangas\", \"Kerangasâ€¦\n$ Habitat_type <chr> \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Intact\", \"Intactâ€¦\n$ Plot_name    <chr> \"KU1\", \"KU2\", \"KU3\", \"KU4\", \"KU5\", \"KU6\", \"KI1\", \"KI2\", \"â€¦\n$ Latitude     <chr> \"4Â° 35' 53.40\\\"N\", \"4Â° 35' 38.37\\\"N\", \"4Â° 35' 53.89\\\"N\", â€¦\n$ Longitude    <chr> \"114Â° 30' 39.09\\\"E\", \"114Â° 31' 05.89\\\"E\", \"114Â° 30' 38.90â€¦\n```\n\n\n:::\n:::\n\n\nThe first three columns are essentially the identifiers of the plots (forest type, habitat type, and the unique identification code for the study plot). However, the latitude and longitude needs a bit of cleaning up, because it's currently in character format. This needs to be in a formal Degree Minute Second `DMS` class that R can understand. For this we will use the `sp::char2dms()` function.\n\nAs an example let's take a look at the first latitude.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nx <- soil_gps$Latitude[1]\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"4Â° 35' 53.40\\\"N\"\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n# convert it using sp::char2dms() function\nx <- sp::char2dms(x, chd = \"Â°\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4d35'53.4\"N\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\nstr(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFormal class 'DMS' [package \"sp\"] with 5 slots\n  ..@ WS : logi FALSE\n  ..@ deg: int 4\n  ..@ min: int 35\n  ..@ sec: num 53.4\n  ..@ NS : logi TRUE\n```\n\n\n:::\n:::\n\n\nThis is a special class that R understands as being a latitude from Earth. To convert it to decimal, we just do `as.numeric()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.598167\n```\n\n\n:::\n:::\n\n\nNow let's do this for all the values in the `soil_gps` data. We will use the `dplyr::mutate()` function in a pipeline.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsoil_gps <-\n  soil_gps |>\n  mutate(\n    Latitude = as.numeric(sp::char2dms(Latitude, chd = \"Â°\")),\n    Longitude = as.numeric(sp::char2dms(Longitude, chd = \"Â°\"))\n  )\nsoil_gps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 Ã— 5\n   Forest_type Habitat_type Plot_name Latitude Longitude\n   <chr>       <chr>        <chr>        <dbl>     <dbl>\n 1 Kerangas    Intact       KU1           4.60      115.\n 2 Kerangas    Intact       KU2           4.59      115.\n 3 Kerangas    Intact       KU3           4.60      115.\n 4 Kerangas    Intact       KU4           4.63      114.\n 5 Kerangas    Intact       KU5           4.60      115.\n 6 Kerangas    Intact       KU6           4.60      115.\n 7 Kerangas    Invaded      KI1           4.59      115.\n 8 Kerangas    Invaded      KI2           4.59      115.\n 9 Kerangas    Invaded      KI3           4.59      115.\n10 Kerangas    Invaded      KI4           4.59      115.\n11 Kerangas    Invaded      KI5           4.59      115.\n12 Kerangas    Invaded      KI6           4.59      115.\n13 Kerangas    Plantation   AP1           4.59      115.\n14 Kerangas    Plantation   AP2           4.59      115.\n15 Kerangas    Plantation   AP3           4.59      115.\n16 Kerangas    Plantation   AP4           4.59      115.\n17 Kerangas    Plantation   AP5           4.59      115.\n18 Kerangas    Plantation   AP6           4.59      115.\n```\n\n\n:::\n:::\n\n\n## Preliminary plot of the data\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmkm_sf |>\n  ggplot() +\n  geom_sf() +\n  geom_point(data = soil_gps, aes(Longitude, Latitude)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Merge with the study data\n\n<!-- ```{r} -->\n\n<!-- ggplot(kpg_sf) + -->\n\n<!--   geom_sf(aes(fill = mukim), col = \"gray50\") + -->\n\n<!--   geom_sf(data = mkm_sf, col = \"black\", lwd = 0.5, fill = NA) + -->\n\n<!--   geom_sf(data = filter(kpg_sf, is.na(mukim)), fill = \"gray70\", col = \"gray70\") + -->\n\n<!--   scale_fill_viridis_d(option = \"turbo\") + -->\n\n<!--   theme(legend.position = \"none\")  -->\n\n<!-- ``` -->\n\n# Brunei population\n\n::: {.callout-tip title=\"What we'll learn\"}\n-   Represent statistical data using colour mapping symbology (choropleth)\n-   Use `ggplot2::geom_label()` or `ggrepel::geom_label_repel()` to add labels to the map\n-   Using a binned colour scale, e.g. `ggplot2::geom_scale_fill_viridis_b()`\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbn_pop_sf <- \n  left_join(\n    kpg_sf, \n    bn_census2021, \n    by = join_by(id, kampong, mukim, district\n  ))\n\nkpg_labels_sf <-\n  bn_pop_sf |>\n  arrange(desc(population)) |>\n  slice_head(n = 10)\n\nbn_pop_sf |>\n  # filter(population > 50) |>\n  ggplot() +\n  geom_sf(aes(fill = population), col = NA, alpha = 0.8) +\n  geom_sf(data = kpg_sf, fill = NA, col = \"black\") +\n  ggrepel::geom_label_repel(\n    data = kpg_labels_sf,\n    aes(label = kampong, geometry = geometry),\n    stat = \"sf_coordinates\",\n    inherit.aes = FALSE,\n    box.padding = 1,\n    size = 2,\n    max.overlaps = Inf\n  ) +\n  scale_fill_viridis_b(\n    name = \"Population\",\n    na.value = NA,\n    labels = scales::comma,\n    breaks = c(0, 50, 100, 1000, 5000, 10000, 15000)\n    # limits = c(0, 12000)\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=100%}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}